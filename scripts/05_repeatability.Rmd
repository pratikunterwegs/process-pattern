---
editor_options: 
  chunk_output_type: console
---
# Repeatability of distance moved

```{r}
library(data.table)
library(dplyr)

library(lme4)
library(rptR)
```

## Prepare data

### Read data

```{r}
paths = list.files(path = "data/lt_tracks", full.names = T)

# read files
data = lapply(paths, fread)
# bind data
data = rbindlist(data)

# remove all weights
data_move = data[, !(c(sprintf("wt_%i", seq(8)), "gen"))]
```

### Summarise over intervals

```{r}
data_move = data_move[, list(
  mean_distance = mean(distance),
  sd_distance = sd(distance),
  mean_r = mean(mean_r)
), by = c("id", "interval", "growth", "type", "rep_")]

# save
fwrite(
  data_move,
  file = "data/data_for_rpt.csv"
)
 rm(data)
```

## Scale data

```{r}
data_scaled = data_move[, lapply(.SD, scales::rescale), 
          by = c("growth", "type", "rep_", "interval")]
data_scaled[, id := floor(id * 99)]
```

## Repeatability analysis

### Function for repeatability

```{r}
get_repeatability = function(df) {
  rptR::rpt(mean_distance ~ mean_r + (1 | id) + (1 | interval), 
            grname = "id", 
            data = df, 
            datatype = "Gaussian", nboot = 100, npermut = 10)
}
```

### Get repeatabilities

```{r}
# nest data
data_scaled = data_scaled[, list(
  data = list(.SD)
), by = c("growth", "type", "rep_")]

# apply function over nested data
data_scaled[, mod_rpt := lapply(data, get_repeatability)]

data_scaled[, c("rpt_v", "rpt_se") := list(
  vapply(mod_rpt, function(m) m$R$id[1], FUN.VALUE = 1.0),
  vapply(mod_rpt, function(m) m$se$se[1], FUN.VALUE = 1.0)
)]
```

### Save data

```{r}
data_rpt = data_scaled[, c("growth", "type", "rep_", "rpt_v", "rpt_se")]

fwrite(data_rpt, file = "data/data_repeatability.csv")
```
